`: Within-word separation.
|: Between-word separation.

@@
@@ Object Setup
@@

@@ Global Objects:
@@
@@ Sheet (db_sheet)
@@ Roll (db_roll)
@@ Fate (db_fate)
@@ Stress (db_stress)

@@ Upstream Objects:
@@
@@ Player Ancestor (db_player)
@@ Chargen Object (db_chargen)
@@ Global Function Object (db_fun)

@@ The Chargen object must have the Sheet object's number in its DB_SHEET attribute.

@@
@@ +Roll Object
@@
&FUN`REGISTER +Roll Object=[@@(Accepts standard roll syntax ([<skill>][+<mods>] [=<recipients>] [(<comments>)]). Sets Skill+mods into %q0, recipients into %q1, and comments into %q2. If an arg is not provided, it is set as a null string.)][@@(Mods into %q0.)][setq(0,trim(edit(before(before(%0,[@@(Open paren.)]chr(40)),=),+,%b+,-,%b-,+%b,+,-%b,-)))][@@(Players into %q1.)][setq(1,trim(before(after(%0,=),[@@(Open paren.)]chr(40))))][@@(Comment into %q2.)][setq(2,if([@@(Is the rightmost character a close paren?)]eq(ord(right(setr(2,trim(after(%0,[@@(Open paren)]chr(40)))),1)),41),[@@(Trim the rightmost character.)]left(%q2,dec(strlen(%q2))),[@@(Give it as-is.)]%q2))]

@@ Syntax: +roll[/q] [<Skill>] [<modifiers>] [=<player1 player2 player3>] [(<comments>)]
&cmd`roll`arg +Roll=$+roll *:think u(fun`register,%0);@pemit %#=u(ansi) [switch(0,[@@(Are they free to roll?)]not(hasattr(%#,_roll)),You already have a roll active[chr(44)] which must be resolved before you continue. Use +roll/accept or +roll/clear.,[@@(Are they using a skill? If so, does it match an actual skill? Sets grabbed skill into %q<skill>.)]cor(not(isword(first(%q0))),complete(get(%#/_skills`list),first(%q0),skill,skill,|)),%qe,[@@(If recipients are provided, do they match actual players? Sets player DBrefs into %q<players>.)]switch(%q1,,[@@(Null string, all good)]1,[@@(Are they all players?)]lmath(and,iter(%q1,if(hastype(setr(i,switch(%i0,me,%#,pmatch(%i0))),player),[@@(It's a player. Append to the player list.)]1[setq(players,insert(%q<players>,-1,%qi))],[@@(It's not a player. Append to the error register.)]0[setq(e,insert(%qe,-1,%i0))])))),Error: [itemize(%qe)] [switch(words(%qe),1,is not a player,are not players)].,[@@(Are they all online?)]lmath(and,iter(%q<players>,if(hasflag(%i0,connected),1,0[setq(e,insert(%qe,-1,%i0))]))),Error: [itemize(iter(%qe,moniker(%i0),,|),|)] [switch(words(%qe),1,is,are)] not online.,[setr(z,[switch(%q<players>,,[@@(Null string. Do nothing.)],(Private: [itemize(sort(iter(%$0,moniker(%i0),,|),i,|),|)])%b)]%k rolls the Fate dice[switch(%q<skill>,,,%b+ %q<skill>)][switch(setr(mods,lmath(add,%q0)),0,[@@(Show nothing.)],<0,%b%$0,>0,%b+%$0)]. Result: [iter(setr(dice,iter(1 2 3 4,rand(-1,1))),switch(%i0,-1,-,1,+,0))] ([switch(lmath(add,%q<dice>),<0,%$0,+%$0)]). Total: [ladder(lmath(add,%q<dice> %q<mods> [setr(bonus,u(v(db_sheet)/fun`skill`rating,%#,%q<skill>))]))].[switch(%q2,[@@(No comment)],[@@(Show nothing)],%b[ansi(xh,(%$0))])][@@(Save in the _roll attribute, in the format 1.dice|2.skill name|3. situational modifiers|4.skill and invoke bonuses|5.players for private rolls|6.comment)][attrib_set(%#/_roll,%q<dice>|%q<skill>|%q<mods>|%q<bonus>|[setr(players,switch(%q<players>,[@@(No players)],[@@(Null string)],setunion(%q<players>,%#)))]|%q2)][setq(y,1)])])];@assert %qy;@switch %q<players>=,{@@ Null string. It's in the room.;@oemit %#=u(ansi) %qz;},{@@ Non-null string. It's private.;@pemit/list remove(%q<players>,%#)=u(ansi) %qz}

&cmd`roll`q`arg +Roll=$+roll/q *:think u(fun`register,%0);@pemit %#=u(ansi) [switch(0,[@@(Are they using a skill? If so, does it match an actual skill? Sets grabbed skill into %q<skill>.)]cor(not(isword(first(%q0))),complete(get(%#/_skills`list),first(%q0),skill,skill,|)),%qe,[@@(If recipients are provided, do they match actual players? Sets player DBrefs into %q<players>.)]switch(%q1,,[@@(Null string, all good)]1,[@@(Are they all players?)]lmath(and,iter(%q1,if(hastype(setr(i,switch(%i0,me,%#,pmatch(%i0))),player),[@@(It's a player. Append to the player list.)]1[setq(players,insert(%q<players>,-1,%qi))],[@@(It's not a player. Append to the error register.)]0[setq(e,insert(%qe,-1,%i0))])))),Error: [itemize(%qe)] [switch(words(%qe),1,is not a player,are not players)].,[@@(Are they all online?)]lmath(and,iter(%q<players>,if(hasflag(%i0,connected),1,0[setq(e,insert(%qe,-1,%i0))]))),Error: [itemize(iter(%qe,moniker(%i0),,|),|)] [switch(words(%qe),1,is,are)] not online.,[setr(z,[switch(%q<players>,,[@@(Null string. Do nothing.)],(Private: [itemize(sort(iter(%$0,moniker(%i0),,|),i,|),|)])%b)]%k quickly rolls the Fate dice[switch(%q<skill>,,,%b+ %q<skill>)][switch(setr(mods,lmath(add,%q0)),0,[@@(Show nothing.)],<0,%b%$0,>0,%b+%$0)]. Result: [iter(setr(dice,iter(1 2 3 4,rand(-1,1))),switch(%i0,-1,-,1,+,0))] ([switch(lmath(add,%q<dice>),<0,%$0,+%$0)]). Total: [ladder(lmath(add,%q<dice> %q<mods> [setr(bonus,u(v(db_sheet)/fun`skill`rating,%#,%q<skill>))]))].[switch(%q2,[@@(No comment)],[@@(Show nothing)],%b[ansi(xh,(%$0))])][setq(y,1)])])];@assert %qy;@switch %q<players>=,{@@ Null string. It's in the room.;@oemit %#=u(ansi) %qz;},{@@ Non-null string. It's private.;@pemit/list remove(%q<players>,%#)=u(ansi) %qz}

@@ Note: Saved +roll information is stored in a player's _roll attributes. This information is of the format 1.dice|2.skill name|3. situational modifiers|4.skill and invoke bonuses|5.players for private rolls|6.comment

@@ Syntax: +roll/clear: Clears your active roll without a broadcast.
&cmd`roll/clear +Roll=$+roll/clear:@assert hasattr(%#,_roll)=@pemit %#=u(ansi) You don't have a roll active.;@pemit %#=u(ansi) You clear your active roll.[attrib_set(%#/_roll)]

@@
@@ Global Functions
@@

@@ Some global functions are necessary for the game to run. These should be placed somewhere they'll be @function-ised on startup.

@@ complete() is used to auto-complete selecting an item from a list - such as selecting one skill to roll.

&GFUN`COMPLETE Global Function Object=[@@(Takes list %0, argument %1, expected type %2, register %3, and optional separator %4. Autocompletes %1 into an element of %0, storing it in register %3. If successful, returns 1. If unsuccessful, returns 0 and saves error message in %qe. Registers e and %3 must be preserved.)]switch(1,words(setr(%3,grab(%0,%1,%4)),%4),1,not(words(setr(%3,graball(%0,%1*,%4)),%4)),0[setq(e,'%1' is an invalid %2.)],gt(words(r(%3),%4),1),0[setq(e,Do you mean %2 [itemize(r(%3),%4,or)]? Write out the full name if necessary.)],1)

@@ ladder() is used to convert a number into the given rating on the Fate Ladder.

&GFUN`LADDER Global Function Object=switch(%0,<-2,Terrible[add(%0,2)],-2,Terrible,-1,Poor,0,Mediocre,1,Average,2,Fair,3,Good,4,Great,5,Superb,6,Fantastic,7,Epic,8,Legendary,Legendary+[sub(%0,8)]) ([if(gte(%0,0),+)]%0)

@@ Config Setup

@@ You must have the following tiny @config options set:
@@ null_eq_zero = true
@@ tiny_math = true

@@
@@ Aspects
@@

@@ Aspects are stored in one attribute per player: the _aspects attribute. Each aspect has a name and a note. The format is 'name1`note1|name2`note2...|nameN`noteN'.

@@ By default, a Fate Accelerated Edition character can have up to 5 aspects: The High Concept, Trouble, and three others.
@@ This is a dial, and can be changed. The _aspects`max attribute on each player (and the Player Parent) is an integer determining the maximum number of aspects.

&_aspects`max Player Parent=5

@@ Some aspects may be special. In FAE and Fate Core, the first aspect is the High Concept and the second is the Trouble. Other Fate-based games have different terminology. The attribute _aspects`names stores special names for numbered aspects. The format is '<number1>.<name1>|<number2>.<name2>...|<numberN>.<nameN>'. If an aspect number is not mentioned in this attribute, it won't be given a special name.

&_aspects`names Player Parent=1`High Concept|2`Trouble

@@ The way aspects are displayed is determined by the fun`sheet`aspects attribute on the +Sheet Object. I recommend that the display show each aspect's number, as those will be used by the aspect-setting commands.

&fun`sheet`aspects +Sheet=[@@(Takes player %0 and returns their aspects, including notes.)][localize([@@(Set the whole list of aspects into %q<aspects>, for use during the iter.)][setq(aspects,get(%0/_aspects))][@@(Set the list of aspect names into %q<names>, for use during the iter.)][setq(names,get(%0/_aspects`names))][iter(lnum(1,get(%0/_aspects`max)),[@@(Aspect special name.)][switch(grab(%q<names>,%i0`*,|),,[@@(Null string, so do nothing special.)],[@@(They made a grab. Prepend the aspect with it.)]%b%b[rest(%$0,`)]%r)][@@(Aspect number and name.)]%i0. [first(setr(0,elements(%q<aspects>,%i0,|)),`)][@@(Aspect note.)][switch(last(%q0,`),,[@@(Null string. Do nothing.)],[@@(Display the note.)]%r%t%$0)],%b,%r%r)])]

@@ Aspects are set in the character creation (chargen) system using the following commands.
@@ +aspects: Shows you your current aspects.
@@ +aspects/name <num>[=<aspect name>]: Names that aspect. If <aspect name> is omitted, erases the aspect, both name and note, from the character.
@@ +aspects/note <num>[=<aspect note>]: Writes a note describing that aspect. If <aspect note> is omitted, erases the aspect, both name and note, from the character.
@@ +aspects/wipe: Wipes all the aspects you've written.

&cmd`aspects Chargen=$+aspects:@pemit %#=u(v(db_sheet)/fun`sheet`aspects,%#)

&cmd`aspects`name Chargen=$+aspects/name *:@break strmatch(%0,*=*);@pemit %#=u(ansi) [switch(0,[@@(Is it an integer greater than zero?)]cand(isint(%0),gt(%0,0)),Aspect number must be a whole number greater than zero.,[@@(Is it within their aspect limits? Sets max aspects into %qm.)]lte(%0,setr(m,get(%#/_aspects`max))),You can only have %qm aspect[switch(%qm,1,,s)].,[@@(Do they have it set? Sets full aspect list into %q<aspects> and target aspect into %q0.)]strlen(first(setr(0,elements(setr(aspects,get(%#/_aspects)),%0,|)),`)),There is no aspect to erase.,You erase your aspect %0.[setq(y,1)])];@assert %qy;think [attrib_set(%#/_aspects,[replace(%q<aspects>,%0,`,|)])]

&cmd`aspects`name_arg chargen=$+aspects/name *=*:@pemit %#=u(ansi) [switch(0,[@@(Is it an integer greater than zero?)]cand(isint(%0),gt(%0,0)),Aspect number must be a whole number greater than zero.,[@@(Is it within their aspect limits? Sets max aspects into %qm.)]lte(%0,setr(m,get(%#/_aspects`max))),You can only have %qm aspect[switch(%qm,1,,s)].,[@@(Have they provided a name, or do they have the aspect set? Sets full aspect list into %q<aspects> and target aspect into %q0.)]or(strlen(%1),strlen(first(setr(0,elements(setr(aspects,get(%#/_aspects)),%0,|)),`))),There is no aspect to erase.,[@@(Have they provided a name?)]strlen(%1),You erase your aspect %0.[setq(y,1)],[@@(Do they avoid illegal ` and | characters?)]not(lmath(or,iter(` |,strmatch(%1,*%i0*)))),You may not use backquote (`) or pipe (|) characters in aspect names.,You name your aspect %0 '%1'[setq(y,1)])];@assert %qy;think [attrib_set(%#/_aspects,[replace(%q<aspects>[@@(Use repeat() in case the aspect list is not actually full.)][repeat(|`,sub(%qm,words(%q<aspects>,|)))],%0,%1`,|)])]

&cmd`aspects`note Chargen=$+aspects/note *:@break strmatch(%0,*=*);@pemit %#=u(ansi) [switch(0,[@@(Is it an integer greater than zero?)]cand(isint(%0),gt(%0,0)),Aspect number must be a whole number greater than zero.,[@@(Is it within their aspect limits? Sets max aspects into %qm.)]lte(%0,setr(m,get(%#/_aspects`max))),You can only have %qm aspect[switch(%qm,1,,s)].,[@@(Do they have it set? Sets full aspect list into %q<aspects> and target aspect into %q0.)]strlen(last(setr(0,elements(setr(aspects,get(%#/_aspects)),%0,|)),`)),There is no note to erase.,You erase the note for your aspect %0.[setq(y,1)])];@assert %qy;think [attrib_set(%#/_aspects,[replace(%q<aspects>,%0,[first(%q0,`)]`,|)])]

&cmd`aspects`note_arg Chargen=$+aspects/note *=*:@pemit %#=u(ansi) [switch(0,[@@(Is it an integer greater than zero?)]cand(isint(%0),gt(%0,0)),Aspect number must be a whole number greater than zero.,[@@(Is it within their aspect limits? Sets max aspects into %qm.)]lte(%0,setr(m,get(%#/_aspects`max))),You can only have %qm aspect[switch(%qm,1,,s)].,[@@(Have they provided a note, or do they have the aspect note set? Sets full aspect list into %q<aspects> and target aspect into %q0.)]or(strlen(%1),strlen(last(setr(0,elements(setr(aspects,get(%#/_aspects)),%0,|)),`))),There is no note to erase.,[@@(Have they provided a name?)]strlen(%1),You erase your aspect %0's note.[setq(y,1)][@@(Do they avoid illegal ` and | characters?)]not(lmath(or,iter(` |,strmatch(%1,*%i0*)))),You may not use backquote (`) or pipe (|) characters in aspect notes.,,You write your aspect %0's note:%r%r%1[setq(y,1)])];@assert %qy;think [attrib_set(%#/_aspects,[replace(%q<aspects>[@@(Use repeat() in case the aspect list is not actually full.)][repeat(|`,sub(%qm,words(%q<aspects>,|)))],%0,[replace(%q0,2,%1,`)],|)])]

&cmd`aspects`wipe Chargen=$+aspects/wipe:@pemit %#=u(ansi) You wipe all your aspects.[attrib_set(%#/_aspects)]

@@
@@ Skills
@@

@@ Approaches are equivalent to other Fate games' skills. For the sake of portability, code and documentation will refer to approaches as skills.

@@ Each player (and the player parent) stores a _skills`list attribute. This attribute is a |-separated list of the skills in use on a particular game. The | is used in case of skills with spaces in the names. To change the skill list, change this attribute.

&_skills`list Player=Careful|Clever|Flashy|Forceful|Quick|Sneaky

@@ Skills are stored in the _skills`skills attribute, which has the format '<skill1 name>`<skill1 rating>|<skilll2 name>`<skill2 rating>...|<skillN name>`<skillN rating>', and is set by chargen commands.

@@ Many Fate games place a cap on the bonus a skill can achieve. This is stored in the attribute _skills`cap, as an integer. If the number is <= 0, the player is treated as having an unlimited skill cap.

&_skills`cap Player=0

@@ In Fate.exe code, significant milestones are handled by the _skills`points attribute. A FAE character starts with 2 Average, 2 Fair, and 1 Good mode - the equivalent of 9 skill points. Skill points increase with significant+ milestones, and determine how many skills the player can have, and how high.

&_skills`points Player=9

@@ Some versions of Fate use a 'columns' system in their skills. You can only have as many skills at Great as you have at Good, and as many as you have at Fair, and so on. Whether a game obeys the column rules is determined by the boolean in the player ancestor's _skills`columns attribute.
@@ FAE does not use columns, so it is set to 0.

&_skills`columns Player=0

@@ The sheet object stores functions to display skills, and calculate remaining skill points. These must be done differently for games using the columns system, but that will be covered later.

&fun`sheet`skills Sheet=[@@(Takes player %0 and displays their skills, choosing the correct column method.)]if(get(%#/_skills`columns),u(fun`sheet`skills`column,%#),u(fun`sheet`skills`nocolumn,%#))

&fun`sheet`skills`nocolumn Sheet=[@@(Takes player %0 and displays their skills, using no-column methods.)]
if(hasattr(%0,_skills`skills),iter(get(%0/_skills`skills),first(%i0,`): [ladder(last(%i0,`))],|,%r),No skills chosen.)%r%rSkill points: [u(fun`skill`points`nocolumn,%#)]/[get(%#/_skills`points)]

@@ The command +skills, in chargen, shows the player's own skills.

&cmd_skills Chargen=$+skills:@pemit %#=u(v(db_sheet)/fun`sheet`skills,%#)

@@ The sheet object stores a function to fetch the player's rating in a skill.

&fun`skill`rating Sheet=[@@(Takes player %0 and full skill name %1 and returns the skill's rating, or 0 if the player doesn't have it.)]max(0,last(grab(get(%0/_skills`skills),%1`*,|),`))

@@ In chargen, set no-column skills' rating with +skills/set <skill>=<rating>.

&cmd_skills/set_nocolumn Chargen=$+skills/set *=*:@break get(%#/_skills`columns)=@@ The player uses columns and so does not use this version of the command.;@pemit %#=switch(0,[@@(Does %0 match a skill? Sets grabbed skill into %q0.)]complete(get(%#/_skills`list),%0,skill,0,|),%qe,[@@(Is %1 an integer >= 0?)]cand(isint(%1),gte(%1,0)),Skills cannot be rated below [ladder(0)].,[@@(Is %1 within the cap? Sets skill cap into %q<cap>.)]cor([@@(Is the character cap-free?)]lte(setr(cap,get(%#/_skills`cap)),0),[@@(Is %1 <= %q<cap>?)]lte(%1,%q<cap>)),You can't have skills rated above [ladder(%q<cap>)].,[@@(Is %1 different from the current rating for %q0? Sets current rating into %qa.)]neq(%1,setr(a,u(v(db_sheet)/fun`skill`rating,%#,%q0))),Your %q0 is already [ladder(%1)].,[@@(Do they have enough skill points? Sets skill points into %q<points>.)]gte(sub([@@(Total skill points, including refund.)]add(setr(points,u(v(db_sheet)/fun`skill`points`nocolumn,%#)),%q1),[@@(Subtract the cost of the new rating.)]%1),0),You only have %q<points> skill point[switch(%q<points>,1,,s)].,[@@(Is %q0 already on the sheet?)]neq(0,%qa),You add %q0 to your sheet[chr(44)] at [ladder(%1)].[attrib_set(%#/_skills`skills,[switch(get(%#/_skills`skills),,[@@(It's an empty string. This skill is all that goes in there.)]%q0`%1,[@@(It's not empty. Insert and sort as normal.)]sort(insert(%$0,-1,%q0`%1,|),a,|))])],[@@(Is %1 greater than zero?)]gt(%1,0),You remove %q0 from your sheet[chr(44)] setting it to [ladder(0)].[switch(words(setr(all,get(%#/_skills`skills)),|),1,[@@(Only one skill to begin with. Wipe the attribute.)]attrib_set(%#/_skills`skills),[@@(There are multiple. Remove it.)]attrib_set(%#/_skills`skills,[remove(%q<all>,%q0`%qa,|)]))],You set %q0 to [ladder(%1)].[attrib_set(%#/_skills`skills,[replace(setr(all,get(%#/_skills`skills)),match(%q<skills>,%q0`%qa,|),%q0`%1,|)])])

@@ In chargen, swap skills' ratings with +skills/swap <skill1>=<skill2>.

&cmd_skills/swap Chargen=$+skills/swap *=*:@pemit %#=switch(0,[@@(Does %0 match a skill? Sets grabbed skill into %q0.)]complete(setr(skills,get(%#/_skills`list)),%0,skill,0,|),%qe,[@@(Does %1 match a skill? Sets grabbed skill into %q1.)]complete(%q<skills>,%1,skill,1,|),%qe,[@@(Are the current ratings different? Sets %q0's rating into %qa, and %q1's rating into %qb. Also set the player's _skills`skills into %q<all>.)]neq(setr(a,u(v(db_sheet)/fun`skill`rating,%#,%q0)),setr(b,u(v(db_sheet)/fun`skill`rating,%#,%q1)))[setq(all,get(%#/_skills`skills))],Both %q0 and %q1 are rated at [ladder(%qa)]. There is no point in swapping them.,[@@(Is %qa > 0?)]gt(%qa,0),You remove %q1 from your sheet and put %q0 in its place at [ladder(%qb)].[attrib_set(%#/_skills`skills,[sort(replace(%q<all>,match(%q<all>,%q1`%qb,|),%q0`%qb,|),i,|)])],[@@(Is %qb > 0?)]gt(%qb,0),You remove %q0 from your sheet and put %q0 in its place at [ladder(%qa)].[attrib_set(%#/_skills`skills,[sort(replace(%q<all>,match(%q<all>,%q0`%qa,|),%q1`%qa,|),i,|)])],You swap the ratings of %q0 (now [ladder(%qb)]) and %q1 (now [ladder(%qa)]).[attrib_set(%#/_skills`skills,[setdiff(get(%#/_skills`skills)|%q0`%qb|%q1`%qa,%q0`%qa|%q1`%qb,|,i)])])

@@ In chargen, column skills must have 'slots' at the different ratings, to ensure that the columns behave as they should.
@@ +skills/slots <rating>=<num>: Sets that number of slots.
@@ +skills/set <skill>=<rating>
@@ +skills/swap <skill1>=<skill2>
@@ +skills/shift <skill>=<new rating>

&fun`skill`highest Sheet=[@@(Takes column-skilled player %0. Returns the highest of their skill cap or their highest-selected skill slot.)]max(get(%0/_skills`cap),lmath(max,iter(get(%0/_skills`slots),first(%i0,`),|,%b)))

&fun`skill`points`column Sheet=[@@(Takes column-skilled player %0, and returns their currently available skill points.)]lmath(sub,get(%0/_skills`points) [iter(get(%0/_skills`slots),mul(first(%i0,`),last(%i0,`)),|,%b)])

&fun`sheet`skills`column Sheet=[@@(Takes player %0 and displays their skills, using column methods.)]localize([setq(slots,get(%0/_skills`slots),skills,get(%0/_skills`skills))][iter(lnum(u(fun`skill`highest,%0),1),%t[ladder(%i0)] ([@@(How many skills at that rating?)][words(setr(0,graball(%q<skills>,*`%i0,|)),|)]/[@@(How many slots at that rating?)][max(0,last(grab(%q<slots>,%i0`*,|),`))]):%r[switch(%q0,,none,itemize(iter(%q0,first(%i0,`),|,|),|))],,%r)]%r%rSkill points: [u(fun`skill`points`column,%0)]/[get(%0/_skills`points)])

&cmd_skills/slots Chargen=$+skills/slots *=*:@assert get(%#/_skills`columns)=@pemit %#=You don't use columns, so you don't have to use +skills/slots.;@pemit %#=switch(0,[@@(Is %0 a whole number?)]isint(%0),You must specify the skill rating by its number.,[@@(Is %0 > 0?)]gt(%0,0),You don't need to buy skill slots below [ladder(1)].,[@@(Is %0 within the skill cap? Sets cap into %q<cap>.)]cor(lte(setr(cap,get(%#/_skills`cap)),0),lte(%0,%q<cap>)),You can't currently have skills rated above [ladder(%q<cap>)].,[@@(Is %1 an integer >= 0?)]cand(isint(%1),gte(%1,0)),You must specify the number of skill slots as a whole number[chr(44)] at least zero.,[@@(Do they have enough skill points? Sets their current slots list into %q<slots> and grabbed slot into %qa.)]gte(sub([@@(Current skill points, including refund for current number of slots at that rating.)]add(u(v(db_sheet)/fun`skill`points`column,%#),mul(first(setr(a,grab(setr(slots,get(%#/_skills`slots)),%0`*,|)),`),last(%qa,`))),[@@(Cost of those slots.)]mul(%0,%1)),0),You don't have enough skill points for that purchase.,[@@(Does the player have few enough skills at %0 to go down to %1?)]lte(words(graball(get(%#/_skills`skills),*`%0,|),|),%1),You have too many skills at [ladder(%0)] to go down to %1 slot[switch(%1,1,,s)].,[@@(Does the player have few enough slots at %0+1 to go down to %1?)]lte(last(grab(%q<slots>,[inc(%0)]`*,|),`),%1),You have too many slots at [ladder(inc(%0))] to go dwon to %1 slot[switch(%1,1,,s)].,[@@(Is %0 1, or does the player have enough slots at %0-1 to support %1?)]cor(eq(1,%0),lte(%1,last(grab(%q<slots>,[dec(%0)]`*,|),`))),You don't have enough slots at [ladder(dec(%0))] to support %1 slot[switch(%1,1,,s)] at [ladder(%0)].,[@@(Is %1 > 0?)]gt(%1,0),[@@(Remove.)][attrib_set(%#/_skills`slots,[ldelete(%q<slots>,match(%q<slots>,%0`*,|),|)])]You now have no slots at [ladder(%0)]. You have [setr(p,u(v(db_sheet)/fun`skill`points`column,%#))] skill point[switch(%qp,1,,s)].,[@@(Do they have any slots at that level yet?)]match(%q<slots>,%0`*,|),[@@(Insert.)][attrib_set(%#/_skills`slots,[switch(%q<slots>,,[@@(Null string. This is all that needs to be set.)]%0`%1,[@@(Needs to be inserted.)]insert(%q<slots>,-1,%0`%1,|))])]You now have %1 slot[switch(%1,1,,s)] at [ladder(%0)]. You have [setr(p,u(v(db_sheet)/fun`skill`points`column,%#))] skill point[switch(%qp,1,,s)].,[@@(Replace.)][attrib_set(%#/_skills`slots,[replace(%q<slots>,match(%q<slots>,%0`*,|),%0`%1,|)])]You now have %1 slot[switch(%1,1,,s)] at [ladder(%0)]. You have [setr(p,u(v(db_sheet)/fun`skill`points`column,%#))] skill point[switch(%qp,1,,s)].)

&cmd_skills/set_column Chargen=$+skills/set *=*:@assert get(%#/_skills`columns);@pemit %#=switch(0,[@@(Does %0 match a skill? Sets grabbed skill into %q0.)]complete(get(%#/_skills`list),%0,skill,0,|),%qe,[@@(Is %1 an integer >= 0?)]cand(isint(%1),gte(%1,0)),Skills cannot be rated below [ladder(0)].,[@@(Is %1 within the cap? Sets skill cap into %q<cap>.)]cor([@@(Is the character cap-free?)]lte(setr(cap,get(%#/_skills`cap)),0),[@@(Is %1 <= %q<cap>?)]lte(%1,%q<cap>)),You can't have skills rated above [ladder(%q<cap>)].,[@@(Is %1 different from the current rating for %q0? Sets current rating into %qa.)]neq(%1,setr(a,u(v(db_sheet)/fun`skill`rating,%#,%q0))),Your %q0 is already [ladder(%1)].,[@@(Do they have an empty slot at that rating? i.e. is the number of skills at that rating less than the number of slots?)]or(lt(%1,1),lt([@@(Number of skills.)]max(0,words(graball(setr(skills,get(%#/_skills`skills)),*`%1,|),|)),[@@(Number of slots.)]last(grab(get(%#/_skills`slots),%1`*,|),`))),You don't have an empty slot at [ladder(%1)].,[@@(Is %q0 already on the sheet?)]neq(0,%qa),You add %q0 to your sheet[chr(44)] at [ladder(%1)].[attrib_set(%#/_skills`skills,[switch(%q<skills>,,[@@(It's an empty string. This skill is all that goes in there.)]%q0`%1,[@@(It's not empty. Insert and sort as normal.)]sort(insert(%$0,-1,%q0`%1,|),a,|))])],[@@(Is %1 greater than zero?)]gt(%1,0),You remove %q0 from your sheet[chr(44)] setting it to [ladder(0)].[switch(words(setr(all,%q<skills>),|),1,[@@(Only one skill to begin with. Wipe the attribute.)]attrib_set(%#/_skills`skills),[@@(There are multiple. Remove it.)]attrib_set(%#/_skills`skills,[remove(%q<all>,%q0`%qa,|)]))],You set %q0 to [ladder(%1)].[attrib_set(%#/_skills`skills,[replace(setr(all,%q<skills>),match(%q<skills>,%q0`%qa,|),%q0`%1,|)])])

&cmd_skills/shift Chargen=$+skills/shift *=*:@assert get(%#/_skills`columns)=@pemit %#=You don't use columns, so you don't have to use +skills/shift.;@pemit %#=switch(0,[@@(Does %0 match a skill? Sets grabbed skill into %q0.)]complete(get(%#/_skills`list),%0,skill,0,|),%qe,[@@(Is %1 an integer?)]isint(%1),Skill rating must be a whole number.,[@@(Is %1 >= 0?)]gte(%1,0),You can't set skills below [ladder(0)].,[@@(Is %1 within the cap? Sets cap into %q<cap>.)]cor([@@(Capless?)]lte(setr(cap,get(%#/_skills`cap)),0),[@@(Within cap?)]lte(%1,%q<cap>)),You cannot have skills above [ladder(%q<cap>)].,[@@(Is %1 different from the current rating? Sets skills into %q<skills>, and current rating into %qa.)]neq(%1,setr(a,max(0,last(grab(setr(skills,get(%#/_skills`skills)),%q0`*,|),`)))),%q0 is already rated [ladder(%qa)].,[@@(Does the player have enough skill points?)]gte(u(v(db_sheet)/fun`skill`points`column,%#),sub(%1,%qa)),You don't have enough skill points to move %q0 from [ladder(%qa)] to [ladder(%1)].,[@@(Test if the columns are stable after removing a slot from %qa. Sets slots into %q<slots>. Sets current number of %qa slots into %q<before>.)]or(eq(%qa,0),gte([@@(Slots at %qa, -1)]dec(setr(before,last(grab(setr(slots,get(%#/_skills`slots)),%qa`*,|),`))),[@@(Slots at %qa+1.)]last(grab(%q<slots>,[inc(%qa)]`*,|),`))),You have too many slots at [ladder(inc(%qa))] to shift a skill away from [ladder(%qa)].,[@@(Is the incremented number of slots at %1 <= the number of slots below %1? Or, is %1 <= 1? Sets current number of %1 slots into %q<after>.)]or(lte(%1,1),lte(inc(setr(after,last(grab(%q<slots>,%1`*,|),`))),last(grab(%q<slots>,[dec(%1)]`*,|),`))),You don't have enough slots at [ladder(dec(%1))] to support a new skill at [ladder(%1)].,[@@(If %q0 is only being upgraded by 1, is the incremented number of slots at %1 still <= the decremented number of slots at %1-1? Or, is %1 <= 1?)]cor(lte(%1,1),neq(%1,inc(%qa)),lte(inc(last(grab(%q<slots>,%1`*,|),`)),dec(last(grab(%q<slots>,[dec(%1)]`*,|),`)))),You don't have enough slots at [ladder(dec(%1))] to support a new skill at [ladder(%1)].,[@@(Setting skills.)][attrib_set(%#/_skills`skills,[setdiff(setr(skills,switch(%q<skills>,,[@@(Null string.)]%q0`%1,sort(insert(%q<skills>,-1,%q0`%1,|),i,|))),%q0`%qa|[graball(%q<skills>,*`0,|)],|,i)])][@@(Setting slots.)][attrib_set(%#/_skills`slots,[setdiff(setr(slots,switch(%q<slots>,,[@@(Null string.)]%1`1,insert(%q<slots>,-1,%qa`[dec(%q<before>)]|%1`[inc(%q<after>)],|))),%qa`%q<before>|%1`%q<after>|[graball(%q<slots>,0`*,|)]|[graball(%q<slots>,*`0,|)],|,i)])]You shift %q0 from [ladder(%qa)] to [ladder(%1)] for a [switch(%qa,>%1,refund,cost)] of [setr(2,abs(sub(%qa,%1)))] skill point[switch(%q2,1,,s)]. You have [setr(p,u(v(db_sheet)/fun`skill`points`column,%#))] skill point[switch(%qp,1,,s)] left.)

@@
@@ Stress
@@

@@ +stress/update: Updates your own stress tracks.
@@ +stress/update <player>: Updates someone else's stress tracks.

&cmd`stress`update_own chargen=$+stress/update:@pemit %#=u(ansi) You update your stress tracks.;@trigger %!/do`stress`update=%#,%#

&cmd`stress`update_other chargen=$+stress/update *:@switch 0=t(setr(0,switch(%0,me,%#,pmatch(%0)))),@pemit %#=u(ansi) '%0' is not a player.,{@pemit %#=u(ansi) You update [switch(moniker(%q0),*s,%$0',%$0's)] stress tracks.;@trigger %!/do`stress`update=%#,%q0}

@@ N.B.: Any time an attribute name incorporates a stress track name, all spaces must be replaced with underscores.
@@ Second note: All active stress attributes (boxes, toughness, extra consequences) will be in _stress`tracks`<track>`<attribute> attributes. This will allow them to be wiped with _stress`tracks`**.
@@ Consequences will go in _stress`data`cons`<level> or in _stress`tracks`<track>`mild`#.

@@ Numerous attributes affect stress tracks: their length, how many there are, any bonus boxes, any bonus consequences, and so on. However, there are very few chargen /commands/ that directly deal with stress.
@@ FAE only uses a single stress track, of three boxes, called 'stress'.
@@ +stress commands outside chargen will, if not given <stress> input, assume the character's first stress track. (For FAE: the basic, single Stress track. For Fate Accelerated: Physical stress. Customised games may have different choices.)

@@ _stress`data`tracks: List of stress track names and their associated skills. Format is 'stress1`skill1|stress2`skill2...|stress3`skill3'. If a stress track has no associated skill, then the skill will always be assumed to be Mediocre (+0) when determining stress tracks.
@@ For Fate Core: &_stress`data`tracks Player=Physical`Physique|Mental`Will
@@ For DFRPG: &_stress`data`tracks Player=Physical`Endurance|Mental`Conviction|Social`Presence
@@ For FAE: &_stress`data`tracks Player=Stress
&_stress`data`tracks Player=Stress

@@ _stress`data`minimum stores the number of boxes you have before bonuses from skills, stunts, and so forth.
@@ For Fate Core: &_stress`data`minimum Player=2
@@ For DFRPG: &_stress`data`minimum Player=2
@@ For FAE: &_stress`data`minimum Player=3
&_stress`data`minimum Player=3

@@ _stress`<track>`bonus stores the number of bonus boxes a character has for that stress track.
@@ _stress`<track>`override stores a FIXED number of boxes a character's base track will have, superseding all skills and bonuses.
@@ _stress`<track>`toughness stores a number of special bonus boxes placed at the end of the character's stress track. This is for compatibility with The Dresden Files RPG's Toughness powers, and games that may use similar.
@@ _stress`<track>`cons stores a number of extra mild consequence slots for a stress track.

@@ On the chargen object, the function fun`stress`skillboxes takes player %0 and stress track %1, and returns the number of stress boxes that character's skill would give that stress track.
&fun`stress`skillboxes Chargen=[@@(Takes player %0 and full stress track name %1. Returns the number of bonus boxes that skill would grant that stress track.)]switch([@@(Get the skill name for that stress track.)]rest(grab(get(%0/_stress`data`tracks),%1`*,|),`),,[@@(Null string, so no skill. Zero.)]0,[@@(String, so there's a skill. Switch based on its rating.)]switch(u(v(db_sheet)/fun`skill`rating,%0,%$0),<1,[@@(Below Average. No extra.)]0,<3,[@@(Below Good. +1 box.)]1,[@@(Good and above. +2 boxes.)]2))

@@ On the chargen object, the function fun`stress`boxes takes player %0 and stress track %1, and returns the total number of stress boxes for that track, taking into account minimums, skills, overrides, and bonuses.
&fun`stress`boxes Chargen=[@@(Takes player %0 and full stress track name %1. Returns the total number of boxes that stress track would have, accounting for skills.)]udefault(%0/_stress`%1`override,add(get(%0/_stress`data`minimum),u(fun`stress`skillboxes,%0,%1),get(%0/_stress`%1`bonus)))

@@ On the player object, _stress`data`cons lists the general-use consequences and their shift values. The format is <con1>`<shift1>|<con2>`<shift2>...|<conN>`<shiftN>.
&_stress`data`cons Player=Mild`2|Moderate`4|Severe`6|Extreme`8

@@ On the chargen object, the function fun`stress`cons takes player %0 and stress track %1, and returns the total number of extra mild consequence slots for that track. This adds the _stress`<track>`cons attribute to the amount gained by skill - 1 for every 2 shifts above Good.

&fun`stress`cons Chargen=[@@(Takes player %0 and full stress track name %1. Returns the total number of bonus mild consequences, accounting for direct bonus consequences and high skill ratings.)]add([@@(Get bonuses.)]u(%0/_stress`%1`cons),switch([@@(Get skill name.)]rest(grab(get(%0/_stress`data`tracks),%1`*,|),`),[@@(Null string)],[@@(Assume zero.)]0,[@@(Else, calculate based on skill rating.)]max(0,div(sub(u(v(db_sheet)/fun`skill`rating,%0,%$0),3),2))))

@@ On the chargen object, the action list 'do`stress`update' updates all stress tracks. It nukes their existing _stress`tracks`** attributes, and rewrites new ones based on their current information.
&do`stress`update chargen=@@ Action list for re-setting character stress. Takes enactor %0 and target %1.;@@ Nuke existing stress.;@wipe %1/_stress`tracks`**;@@ Dolist for all existing stress tracks.;@dolist/delimit | [get(%1/_stress`data`tracks)]={@@ Set stress boxes.;&_stress`tracks`[setr(0,edit(first(%i0,`),%b,_))] %1=[delete(repeat(%bO,u(fun`stress`boxes,%1,%q0)),0,1)];@@ Set extra consequence slots, if necessary.;@switch u(fun`stress`cons,%1,%q0)=>0,{@dol [lnum(1,%$0)]=&_stress`tracks`%q0`Mild%i0 %1=};@@ Set toughness, if necessary.;@switch u(%1/_stress`%q0`toughness)=>0,&_stress`tracks`%q0`toughness %1=[delete(repeat(%bO,%$0),0,1)]}

@@ The sheet object's fun`sheet`stress attribute displays the stress tracks and consequence slots.
&fun`sheet`stress Sheet=[@@(Takes player %0 and returns their stress tracks and consequence slots.)][@@(Show stress tracks.)][iter(get(%0/_stress`data`tracks),[ljust(first(%i0,`):,23)] [get(%0/_stress`tracks`[setr(0,edit(first(%i0,`),%b,_))])][switch(get(%0/_stress`tracks`%q0`toughness),[@@(null string)],[@@(do nothing)],%b(%$0))],|,%r)]%r%r[@@(Show general-user consequences.)][iter(get(%0/_stress`data`cons),ljust(first(%i0,`):,23) [get(%0/_stress`cons`[edit(first(%i0,`),%b,_)])],|,%r)][iter(get(%0/_stress`data`tracks),switch(lattr(%0/_stress`tracks`[setr(0,edit(first(%i0,`),%b,_))]`mild*),[@@(null string)],[@@(do nothing)],%r[iter(sort(%$0),[ljust([first(%i1,`)] [capstr(lcstr(last(%i0,`)))]:,23)] [get(%0/%i0)],,%r)]),|,)]

@@
@@ Stunts
@@

@@ _refresh: Number of refresh points.
@@ _stunts`data`free: Number of free stunts. 
@@ _stunts`data`stunts-refresh: Stunts:refresh ratio.
&_refresh Player=3
&_stunts`data`free Player=3
&_stunts`data`stunts-refresh Player=1:1

@@ _stunts`stunts: The actual stunts taken. Format: codename~showname~cost~note~del|nextstunt.

&fun`stunts`total Sheet=[@@(Takes player %0 and returns their total stunt allocations.)]lmath(add,iter(get(%0/_stunts`stunts),elements(%i0,3,~),|))

&fun`stunts`calc Sheet=[@@(Takes player %0 and optional stunt total %1. Accounts for free stunts and ratios, and returns "<refreshcost> <remainder>". To be used with setq.)]localize(switch([@@(Total stunts allocated.)]switch(%1,[@@(Null string)],u(fun`stunts`total,%0),%1),[@@(Not enough to cost refresh. Sets free stunts into %q<free>.)]>=[mul(-1,setr(free,get(%0/_stunts`data`free)))],[@@(Zero refresh cost.)]0 [@@(Add total allocation to free stunts.)][add(%$0,%q<free>)],[@@(Sets ratio into register. Stunts term into %q<stunts> and refresh term into %q<refresh>.)][iter(get(%0/_stunts`data`stunts-refresh),setq(switch(inum(0),1,stunts,refresh),%i0),:,)][@@(Second, calculate total cost. Sets full numerator into %q0.)][dec(div([@@(Multiply non-free stunts by the refresh term. Sets total term into %q0.)]inc(setr(0,mul(add(%$0,%q<free>),%q<refresh>))),[@@(Divide by stunts term.)]%q<stunts>))] [@@(Third and final, calculate modulo.)][modulo(%q0,%q<stunts>)]))

@@ For calculating “Do they have enough refresh for this?” Assumes that the stunt’s data are in %q<stunt>

@@ gt(add(get(%#/_stunts`refresh),first(u(v(db_sheet)/fun`stunts`calc,%#,add(u(v(db_sheet)/fun`stunts`total,%#),elements(%q<stunt>,3,~))))),0),You don't have enough refresh to buy that stunt.

&fun`stunts`cost Sheet=[@@(Takes player %0 and stunt codename %1. Returns the number of stunts allocated to the first stunt matching that codename.)]elements(grab(get(%0/_stunts`stunts),%1~*,|),3,~)

@@ +stunts: Shows you your stunts.
@@ +stunts/create <name>=<cost>: Creates that stunt live, and adds it to your sheet.
@@ +stunts/note <num>[=<note>]: Adds or removes a note from that stunt.
@@ +stunts/list: Lists the stunt categories.
@@ +stunts/list <category>: Lists the stunts in that category.
@@ +stunts/del <num>: Deletes that stunt from your sheet.
@@ +stunts/cost <num>=<cost>: Changes the cost of that stunt.
@@ +stunts/rename <num>=<new name>: Renames that stunt.

&cmd`stunts Chargen=$+stunts:@pemit %#=u(v(db_sheet)/fun`sheet`stunts,%#)

&cmd`stunts`create Chargen=$+stunts/create *=*:@pemit %#=u(ansi) [switch(0,[@@(Have they provided a name?)]strlen(%0),You must provide a stunt name.,[@@(Does the name withhold illegal characters?)]not(lmath(or,iter(~ |,strmatch(%0,*%i0*)))),You may not have tildes (~) or pipes (|) in stunt names.,[@@(Is %1 an integer?)]isint(%1),Stunt cost must be an integer.,[@@(Can they afford it? Sets cost result into %q<cost>.)]gt(add(get(%#/_refresh),first(setr(cost,u(v(db_sheet)/fun`stunts`calc,%#,add(u(v(db_sheet)/fun`stunts`total,%#),%1))))),0),You don't have enough refresh left to buy %1 stunt[switch(%1,1,,s)].,[attrib_set(%#/_stunts`stunts,[insert(get(%#/_stunts`stunts),-1,[@@(no codename)]~[@@(showname)]%0~[@@(cost)]%1~[@@(no note)]~[@@(no delcommands)],|)])]You create the stunt "%0" [switch(%1,<0,and allocate a cost of [switch(abs(%1),1,%$0 stunt,%$0 stunts)],with a refund of %1 stunt[switch(%1,1,,s)])]. You now have [add(get(%#/_refresh),first(%q<cost>))] refresh and [switch(last(%q<cost>),0,no free stunts,1,1 free stunt,%$0 free stunts)] remaining.)]

&cmd`stunts`note Chargen=$+stunts/note *:@pemit %#=u(ansi) [switch(0,[@@(Is the stunt number valid? Sets stunt number into %q0.)]cand(isint(setr(0,first(%0,=))),gt(%q0,0)),Stunt number must be an integer greater than zero.,[@@(Is the stunt within their list? Sets their full stunt list into %qa and number of stunts to %qw.)]lte(%q0,setr(w,words(setr(a,get(%#/_stunts`stunts)),|))),You only have %qw stunt[switch(%qw,1,,s)].,[@@(Do they provide a comment?)]strmatch(%0,*=*),You clear the note from your stunt %q0.[attrib_set(%#/_stunts`stunts,[replace(%qa,%0,replace(elements(%qa,%0,|),4,,~),|)])],[@@(Does the note withhold illegal characters?)]not(lmath(or,iter(~ |,strmatch(rest(%0,=),*%i0*)))),You may note have tildes (~) or pipes (|) in stunt notes.,You add a note to your stunt %q0[chr(44)] reading "[setr(1,rest(%0,=))]"[attrib_set(%#/_stunts`stunts,[replace(%qa,%0,replace(elements(%qa,%0,|),4,%q1,~),|)])])]

&fun`sheet`stunts Sheet=[@@(Takes player %0 and displays all their stunts.)][iter(get(%0/_stunts`stunts),inum(0). [elements(%i0,2,~)] ([elements(%i0,3,~)]) [if(orflags(%#,WZw),ansi(xh,([first(%i0,~)])))][switch(elements(%i0,4,~),[@@(null string)],[@@(do nothing)],%r%t%$0)],|,%r)]%r%rRefresh: [add(setr(refresh,get(%0/_refresh)),first(setr(cost,u(fun`stunts`calc,%0))))]/%q<refresh>%rStunts until next refresh spent: [last(%q<cost>)]

@@ On the chargen object, the attributes in the tree 'data`stunts`lists`<category>' (e.g. data`stunts`lists`toughness) will store the code for those actual stunts. Format: codename~showname~cost~note~test~buy~del|nextstunt.
@@ test, buy, and del each store code which will be evaluated at those times. If they start with ':', then the rest will be the name of an attribute (on the chargen object, within the data`stunts`* tree) which will be used. Otherwise, that string is itself treated as code. This code must use side-effect functions instead of commands.
@@ The 'test' code must be written as if it begins with 'switch(0,' and ends with a <dflt> that will activate the actual stunt-buying code. %2 will glob everything after the second = sign.
@@ The 'del' code must be escaped once, so that %qX substitutions can work.
@@ [@@(This close-paren is for the sake of neatness in an above paragraph.)] )

&data`stunts`toughness1_test Chargen=
&fun`stunts`test1 Chargen=u(ansi) [switch(0,
&fun`stunts`test2 Chargen=,u(fun`stunts`buy))]
&fun`stunts`buy Chargen=[@@(Set the evaluated code name, display name, and once-evaluated on-del code into %qe.)][attrib_set(%!/temp_%#,[elements(%q<stunt>,1 2 7,~)])][setq(e,u(temp_%#))]You buy "[elements(%q<stunt>,2,~)]" for a [switch(%q<cost>,<0,cost,refund)] of [abs(%q<cost>)] stunt slot[switch(abs(%q<cost>),1,,s)]. You now have [add(get(%#/_refresh),first(%q<calc>))] refresh and [switch(last(%q<calc>),0,no free stunts,1,1 free stunt,%$0 free stunts)] remaining.[@@(Set on-buy attribute.)][attrib_set(%!/temp_%#,[switch(elements(%q<stunt>,6,~),[@@(null string)],No special changes.,:*,[@@(Get attribute)][v(data`stunts`[delete(%$0,0,1)])],[@@(Run code.)]%$0)])]%r[u(ansi)] [u(temp_%#)][@@(Set the on-del into %qd.)][attrib_set(%#/temp_%#,elements(%q<stunt>,7,~))][setq(d,u(temp_%#))][@@(Set the player's stunt list.)][attrib_set(%#/_stunts`stunts,[insert(get(%#/_stunts`stunts),-1,[@@(Codename and display name.)][elements(%qe,1 2,~)]~[@@(Cost.)]%q<cost>~~[@@(On-del.)][last(%qe,~)],|)])][@@(If the on-del is an attribute, set it, once-evaluated, into the player.)][switch(%qd,:*,attrib_set(%#/_stunts`del`[delete(%$0,0,1)],[u(data`stunts`[delete(%$0,0,1)])]))]

&data`stunts`lists`toughness Chargen=Toughness1~Inhuman Toughness~-2~Increases your Physical stress track by 2 Toughness boxes.~not(hasattr(%#,_stress`Physical`Toughness)),You already have a source of Physical Toughness. Please delete that stunt before buying this one.~:toughness1_buy~:toughness1_del|StressBonus:%q<stress>~Bonus Stress~-1~Increases your chosen stress track by 2. +stunts/buy T=2=<stress track>~:stresstest_test~You now have 2 bonus %q<stress> boxes.[attrib_set(%#/_stress`%q<stress>`bonus,2)]~You lose your bonus %q<stress> boxes.\[attrib_set\(\%#/_stress`%q<stress>`bonus\)\]

&data`stunts`stresstest_test Chargen=[@@(Match stress track.)]complete(iter(get(%#/_stress`data`tracks),first(%i0,`),|,|),%0,stress track,stress,|),%qe

&data`stunts`toughness1_buy chargen=You now have 2 Physical Toughness boxes.[attrib_set(%#/_stress`Physical`toughness,2)]
&data`stunts`toughness1_del chargen=You now have no Physical Toughness boxes.\[attrib_set\(\%#/_stress`Physical`toughness\)\]

&cmd`stunts/list Chargen=$+stunts/list:@pemit %#=u(ansi) Stunt categories:%r%r[iter(lattr(%!/data`stunts`lists`*),iter(last(%i0,`),capstr(lcstr(%i0)),_),,%r)]
&cmd`stunts/list_arg Chargen=$+stunts/list *:@pemit %#=u(ansi) [switch(0,[@@(Does %0 match a stunt list? Sets it into %q0 and the spaces-stripped one to %q1.)]complete(iter(lattr(%!/data`stunts`lists`*),iter(last(%i0,`),capstr(lcstr(%i0)),_),,|),%0,stunt list,0,|)[setq(1,edit(%q0,%b,_))],%qe,Stunts in list %q0:%r%r[iter(v(data`stunts`lists`%q1),inum(0). [elements(%i0,2,~)] ([elements(%i0,3,~)])[switch(elements(%i0,4,~),[@@(null string)],[@@(Do nothing)],%r%t%$0)],|,%r)]

&cmd`stunts`buy Chargen=$+stunts/buy *=*:@break strmatch(%1,*=*);@pemit %#=u(ansi) [switch(0,[@@(Does %0 match a stunt list? Sets it into %q0 and the spaces-stripped one to %q1.)]complete(iter(lattr(%!/data`stunts`lists`*),iter(last(%i0,`),capstr(lcstr(%i0)),_),,|),%0,stunt list,0,|)[setq(1,edit(%q0,%b,_))],%qe,[@@(Is %1 an integer >0?)]cand(isint(%1),gt(%1,0)),Stunt number must be a whole number greater than zero.,[@@(Is %1 within the list? Sets list into %q<all>.)]lte(%1,words(setr(all,v(data`stunts`lists`%q1)),|)),The %q0 list only has [words(%q<all>,|)] stunt[switch(words(%q<all>,|),1,,s)].,[@@(Can they afford it? Sets cost result into %q<calc>, stunt into %q<stunt>, and stunt slot cost into %q<cost>.)]gt(add(get(%#/_refresh),first(setr(calc,u(v(db_sheet)/fun`stunts`calc,%#,add(u(v(db_sheet)/fun`stunts`total,%#),setr(cost,elements(setr(stunt,elements(%q<all>,%1,|)),3,~))))))),0),You don't have enough refresh left to buy %q<cost> stunt[switch(%q<cost>,1,,s)].,Attempting to buy %q0 stunt %1[chr(44)] [elements(%q<stunt>,2,~)].[setq(y,1)])];@assert %qy;think attrib_set(%!/temp_%#,[v(fun`stunts`test1)][switch(elements(%q<stunt>,5,~),:*,v(data`stunts`[delete(%$0,0,1)]),%$0)][v(fun`stunts`test2)])[setq(y,0)];@pemit %#=[u(temp_%#,%2)]

&cmd`stunts`buy_arg Chargen=$+stunts/buy *=*=*:@pemit %#=u(ansi) [switch(0,[@@(Does %0 match a stunt list? Sets it into %q0 and the spaces-stripped one to %q1.)]complete(iter(lattr(%!/data`stunts`lists`*),iter(last(%i0,`),capstr(lcstr(%i0)),_),,|),%0,stunt list,0,|)[setq(1,edit(%q0,%b,_))],%qe,[@@(Is %1 an integer >0?)]cand(isint(%1),gt(%1,0)),Stunt number must be a whole number greater than zero.,[@@(Is %1 within the list? Sets list into %q<all>.)]lte(%1,words(setr(all,v(data`stunts`lists`%q1)),|)),The %q0 list only has [words(%q<all>,|)] stunt[switch(words(%q<all>,|),1,,s)].,[@@(Can they afford it? Sets cost result into %q<calc>, stunt into %q<stunt>, and stunt slot cost into %q<cost>.)]gt(add(get(%#/_refresh),first(setr(calc,u(v(db_sheet)/fun`stunts`calc,%#,add(u(v(db_sheet)/fun`stunts`total,%#),setr(cost,elements(setr(stunt,elements(%q<all>,%1,|)),3,~))))))),0),You don't have enough refresh left to buy %q<cost> stunt[switch(%q<cost>,1,,s)].,Attempting to buy %q0 stunt %1[chr(44)] [elements(%q<stunt>,2,~)].[setq(y,1)])];@assert %qy;think attrib_set(%!/temp_%#,[v(fun`stunts`test1)][switch(elements(%q<stunt>,5,~),:*,v(data`stunts`[delete(%$0,0,1)]),%$0)][v(fun`stunts`test2)])[setq(y,0)];@pemit %#=[u(temp_%#,%2)]

&cmd`stunts`del Chargen=$+stunts/del *:@pemit %#=u(ansi) [switch(0,[@@(Is %0 an integer > 0?)]cand(isint(%0),gt(%0,0)),Stunt number must be a whole number greater than zero.,[@@(Do they have that many stunts? Sets full stunt list into %q<all>, and number of stunts into %qw.)]lte(%0,setr(w,words(setr(all,get(%#/_stunts`stunts)),|))),You only have %qw stunt[switch(%qw,1,,s)].,[@@(Can they afford that? Sets calc result into %q<calc>, that stunt into %q<stunt>, and that stunt's cost into %q<cost>.)]gt(add(get(%#/_refresh),first(setr(calc,u(v(db_sheet)/fun`stunts`calc,%#,sub(u(v(db_sheet)/fun`stunts`total,%#),setr(cost,elements(setr(stunt,elements(%q<all>,%0,|)),3,~))))))),0),You can't afford to delete "[elements(%q<stunt>,2,~)]" and lose its refund.,You delete your stunt %0[chr(44)] "[elements(%q<stunt>,2,~)]"[chr(44)] for a [switch(%q<cost>,<0,refund,cost)] of [abs(%q<cost>)] stunt slot[switch(abs(%q<cost>),1,,s)]. You now have [add(get(%#/_refresh),first(%q<calc>))] refresh and [switch(last(%q<calc>),0,no free stunts,1,1 free stunt,%$0 free stunts)] remaining.[@@(If there is on-del code, run it.)][switch(elements(%q<stunt>,5,~),[@@(null string)],[@@(do nothing)],[attrib_set(%!/temp_%#,[switch(%$0,:*,get(%#/_stunts`del`[delete(%$0,0,1)]),%$0)])]%r[u(ansi)] [u(temp_%#)][attrib_set(%#/_stunts`del`[delete(%$0,0,1)])])][@@(Actually change the stunt list.)][attrib_set(%#/_stunts`stunts,[ldelete(%q<all>,%0,|)])])]

&cmd`stunts/rename Chargen=$+stunts/rename *=*:@pemit %#=u(ansi) [switch(0,[@@(Is %0 an integer > 0?)]cand(isint(%0),gt(%0,0)),Stunt number must be a whole number greater than zero.,[@@(Do they have that many stunts? Sets full stunt list into %q<all>, and number of stunts into %qw.)]lte(%0,setr(w,words(setr(all,get(%#/_stunts`stunts)),|))),You only have %qw stunt[switch(%qw,1,,s)].,[@@(Have they provided a name?)]strlen(%1),You must provide a name.,[@@(Does the name withhold illegal characters?)]not(lmath(or,iter(~ |,strmatch(%1,*%i0*)))),You may not have tildes (~) or pipes (|) in stunt names.,You rename stunt %0 to "%1".[attrib_set(%#/_stunts`stunts,[replace(%q<all>,%0,replace(elements(%q<all>,%0,|),2,%1,~),|)])])]

&cmd`stunts/cost Chargen=$+stunts/cost *=*:@pemit %#=u(ansi) [switch(0,[@@(Is %0 an integer > 0?)]cand(isint(%0),gt(%0,0)),Stunt number must be a whole number greater than zero.,[@@(Do they have that many stunts? Sets full stunt list into %q<all>, and number of stunts into %qw.)]lte(%0,setr(w,words(setr(all,get(%#/_stunts`stunts)),|))),You only have %qw stunt[switch(%qw,1,,s)].,[@@(Is cost an integer?)]isint(%1),Stunt cost must be a whole number.,[@@(Can they afford it? Sets original stunt into %q<stunt> and original cost into %q<cost>.)]gt(add(get(%#/_refresh),first(setr(calc,u(v(db_sheet)/fun`stunts`calc,%#,add(sub(u(v(db_sheet)/fun`stunts`total,%#),setr(cost,elements(setr(stunt,elements(%q<all>,%0,|)),3,~))),%1))))),0),You can't afford that many stunt slots.,You change stunt %0[chr(44)] "[elements(%q<stunt>,2,~)]"[chr(44)] to a [switch(%1,<0,cost,refund)] of [abs(%1)] stunt slot[switch(abs(%1),1,,s)]. You now have [add(get(%#/_refresh),first(%q<calc>))] refresh and [switch(last(%q<calc>),0,no free stunts,1,1 free stunt,%$0 free stunts)] left.[attrib_set(%#/_stunts`stunts,[replace(%q<all>,%0,replace(%q<stunt>,3,%1,~),|)])])]